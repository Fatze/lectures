4. Многообразие моделей данных СУБД.

Как мы помним из истории NoSQL, реляционная модель не возникла
из ниоткуда - она представила прекрасный механизм
отделения модели данных от представления данных, а также 
дала возможжность выполнять Ad-hoc запросы к данным, в иделае
лишь изменяя индексы, но не схему данных.

Чего же эта модель не учитывала? 

1. Необходимость в agile & schema change 

2. Variety в 3V понятия Big Data - часто задача data capture
стоит настолько остро, что паттерн ETL (extract-transform-load)
заменяется паттерном LTE. 

Тут надо понимать, что Big Data являетс ялишь одной из причин
возникновения NoSQL, но не единственной

3. Нишевые задачи, такие как работу над графом данных *c новыми
показателями Performance и usabity* - т.е. Joe Celko 
с его 5ю способами решать графовые задачи в реляционных базах
не канает

Мир существующих баз данных, таким образом, можно разделить на 
следующие группы, по моделям данных:

pre-nosql:

- hierarchical - 60x
- network  - 70x
- relational 80x+ (column-oriented store, row-oriented store)
- object databases - почему они не взлетели стоит отдельного анализа)
90x+
- xml databases 2000x+ (также умерли - в основном из-за
слишком высокой сложности реализации и сравнительно низких 
benefits, им на смену пришли более простые document store)

nosql:

- key-value store
- column store (другой смысл! - BigTable columnar store != Vertica column
  store, vertica is a relational database)
- document database
- graph database

NoSQL системы также часто характеризуют как schema-less - это
означает  что нет схемы распространяющиеся на все документы коллекции.

Что же особенного в этих моделях данных?

Во-первых, мы видим что они в разной мере приближены к модели
реализации - relational наиболее абстрагированы, остальные наименее
абстрагированы.

Во-вторых, они в разной мере структурируют данные. В иерархических, 
реляционных, сетевых базах данных данные высоко структурированы, минимальным
атомом хранения является атом - строка, число и т.д.

В-третьих, отношения с метаданными, то есть с информацией о структуре
данных, выстроены в разной мере.
В реляционных базах данных все строки должны удовлетворять схеме даннхы
таблице.

В XML базе данных строки должны следовать DTD - схеме XML данных, но DTD 
однако позволяет документу иметь существенно большую свободу чем 
relatioanl table row. Что важно, в XML DTD по-прежнему, как
в реляционых системах, "извлечён" из документа, то есть общий для всех
документов.

В JSON/document stores каждый объект самоописан, и разные объекты
могут иметь разные схемы, при этом храниться в одной коллекции.
Каждый объект идентифицируется uuid.

В key/value структура объекта вообще неизвестна - key maps to a blob
and the database is value-agnostics, it stores what it gets.

Таким образом мы наглядно видим что данные в разной мере структурированы -
и это отражает проблематику, для решения которой СУБД создавались.

Если на переднем плане стоит data capturing - данные минимально
структурированы.

Если на переднем плане стоит производительность работы с одним
атомом данных - данные структурированы в соответствии с этим сценарием.

Для аналитики и oltp естественным образом наилучшим образом подходят
СУБД с высоким уровня "знания" о структуре перерабатываемых данных.

Специализированные модели, такие как graph databases, подходят исключительно
для специализированынх задач, таких как поиск кратчайшего пути в графе
(например, база данных улиц в городе).

Понятие агрегата
----------------

Попытки найти "идеальную модель" не останавливались с конца 60х годов.  Хотя
модель Кодда идеально подходила для решения задач oltp, и извлечения знаний из
фактов - relational table row is ideal for storing a single piece of factual
data, to understand why - go learn prolog), наличие object-relational
impedance mismatch, а также очевидная неприменимость реляционной модели 
для решения всех существующих задач заставляли вести поиски "более идеальной
модели".

В настоящее время наиболее уместно сказать что "ложки нет" (с) Матрица
- т.е. идеальной модели данных не существует в принципе. 
Наиболее правильным подходом к пониманию структуры данных с которыми
идёт работа является доменно-ориентированны анализ - то есть 
опора на то, каким образом на данные смотрит предметная область,
задачи автоматизации которой решает СУБД.

Также не существует и "идеального представления" данных - в то
время как доминирующей системой хранения реляционных таблиц ыли B-деревья,
в зависимости от задач стоящих перед СУБД даже для хранения
реляционных нормализованных данных более уместными могут быть совершенно
разные алгоритмы, начиная COLA и заканчивая column store.
Очевидно одно - для макс. производительности представление данных
должно следовать или коррелировать с моделью данных, а также, для
одних и тех же данных в зависимости не толкьо от модели но и от
паттерна доступа (больше запись, больше чтение, больше аналитики, больше 
oltp), уместно то или иное представление.

Поэтому часто для понимание моделей данных вводится понятие "агрегата",
то есть наиболее часто запрашиваемого/оперируемого "юнита" данных.

Так, в OLTP системе обработки заказов customers - inventory - orders
"агрегатом" будет являться заказ, в уютной ЖЖшечке - блог пост со всеми 
комментами, в системе хранения профилей - регистрационные данные
пользователя (фиксированный набор полей) *и* коллекция настроек профиля.

Именно с точки зрения "агрегата" удобнее всего понимать модели
данных NoSQL систем: 

-  key - value - одна пара ключ-значение представляет собой агрегат
База данных *ничего* не знает о структуре value

- document store - документ - чаще всего в виде json, идентифицирован
document id,  но внутрення структура документа открыта. 
Схемы нет.

Часто таким образом разница между key-value document размыта
- key value эволиционируют в document store Со временем.

- bigtable - key или key + column family 

Действительно, ограничений схемы на этапе document-store, key-value 
отсутствуют.

Но что если мы хотим сделать запрос по вторичным ключам, то есть
не по aggregate, чаще всего это либо невозможно (key-value), либо предполагает
наличие хотя бы ad-hoc/implicit схемы - то есть в запросе участвуют только
документы имеющие эти индексы. 

Каков же механизм вычисления запросов по Ad-hoc/implicit схеме? Частичные
индексы (документ участвует в индексе только если у него есть определённый
путь типа user.address.city), либо map/reduce (hadoop/pig работает так).

То есть в мире NoSQL мы платим полную цену за то, что не сообщаем базе 
данных достаточно информации о схеме данных и паттернах доступа к данным.
Однако это не являются "определяющей" характеристикой NoSQL - скорее
это подтверждает наличие континуума моделей даннных.

