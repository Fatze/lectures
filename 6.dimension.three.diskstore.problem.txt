6. Размерность хранения данных 

Проблема эффективного хранения и доступа к данным
часто несправедливо остаётся за бортом рассмотрения NoSQL движения.

Одним из факторов сдавания позиций реляционных систем является
морально устаревшая алгоритмическая база для хранения данных.

Большинство систем используют B-trees, для упорядоченного хранения
данных, плюс один из вариантов ARIES семейства алгоритмов для
управления версиями.

Б-деревья как структура данных балансируют производительность
вставок и производительность поиска, и при этом "приносят в жертву"
производительность удаления. Этот баланс также неверен
в типичном Web приложении, с динамично устаревающими данными.

В последнее время широкое распостранение получили cache-oblivious
algorithms, которые часто существенно лучше распараллеливаются
в сравнении с традиционными B-trees, что также немаловажно.

Давайте для примера рассмотрим cache-oblivious b-trees.

Также, в области проблематики хранения находится организация
обработки транзакций на одном узле. В зависимости от моделей данных
различия в алгоритмы блокировок при обработке транзакций становятся
немаловажными.

Также давайте рассмотрим такую простую вещь как префиксная компрессия
в б-дереве.

Наксоклько она актуально для json /xml данных? Очень актуально.
Насколько это актуально для нормализованных данных? ну разве что если тип
данных - строка, причём немаленькая (json/xml :)
Стоит ли заморачиваться с префиксной компрессией и MVCC? Алгоритм 
становится непомерно сложным.

Другим примером является блокировки при параллельном доступе к данным.
Модель данных часто диктует реализацию а реализация, в свою очередь, 
ограничиват пространство манёвра в области модели.

Наиболее типичным объектом в документно-ориентированной модели
является документ. Пусть средний размер документа 1 кб. Давайте попробуем
конкрутентно и транзакционно обновить из 1000 потоков *разные*
узлы по разным json paths. Мы получим стагнацию т.к. все 
конкурентные обновления упрутся в блокировку на документе, т.к.
документно-ориентированная база данных часто не расчитана на конкурентные
обновления конкретных полей, а на перезапись всего документа. 


Не стоит забывать также о такой базовой характеристике СУБД 
как latency. С одной стороны, latency - физическая характеристика, 
т.е. лежит на стороне реализации, но с другой стороны, каким образом
обеспечить низкую latency в map/reduce запросе?

Ну а в графовых СУБД без особенностей реализации и модель становется
ненужной и излишней - все графовые операции можно выразить на языке SQL,
то есть в графовых СУБД *реализация* является исходной посылкой
для создания специфичной модели данных.

Все эти примеры демонстрируют что с одной стороны, варианты
реализации образует дополнительную размерность в области СУБД 
решений, а с другой стороны показывает что пространство решений
не может быть непрерывно, и имеет "точки максимума" вокруг потребностей
рынка и возможностей реализации.
